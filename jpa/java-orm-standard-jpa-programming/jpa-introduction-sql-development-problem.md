# JPA 소개

## 1. SQL 중심적인 개발의 문제점

현재 대부분의 애플리케이션은 객체 지향 언어를 사용하고 데이터는 관계형 데이터베이스에 저장한다. 그렇기 때문에 객체를 데이터베이스에 저장해서 관리해야한다. 하지만 모순적으로 객체지향언어를 사용하는데도 데이터베이스는 SQL만 알아들을 수 있기 때문에 SQL 코드를 많이 작성해야한다. 이유는 테이블에 대한 CRUD를 모두 작성해야하는 번거로움이 있다. 뿐만 아니야 필드에 변화가 생길 때마다 CRUD SQL를 변경해야한다.

=> 즉, 개발자가 SQL 매퍼의 역할을 하고 있다.

<br>

객체지향언어와 관계형데이터베이스의 패러다임이 여러가지 관점에서 다른 것도 문제다.

- 상속 관계

- 연관 관계

- 객체 그래프 검색

- 객체 비교

=> 객체답게 모델링 할수록 매핑하는 작업이 늘어날 수 밖에 없다.

그래서 **객체를 자바 컬렉션에 저장 하듯이 DBdp 저장할 수는 없을까?** 에 대한 고민에 시작한 것이 **JPA**이다.

<br>

## 2. JPA 소개

### 2.1 JPA란?

- Java Persistence API의 줄임말이다.
- 자바 진영의 **ORM** 기술 표준이다.

<br>

### 2.2 ORM이란?

- Object-Relational Mapping(객체 관계 매핑)의 줄임말이다.

객체는 객체대로 설계하고 관계형 데이터베이스는 관계형 데이터베이스대로 설계를 하면 **ORM 프레임 워크**가 중간에서 개발자가 해야하는 매핑 작업을 해준다.

<br>

### 2.3 JPA의 동작

JPA는 Java 애플리케이션과 JDBC 사이에서 동작한다. 즉, 개발가 JDBC API를 직접 이용하지 않고 JPA에게 명령을 보내 JDBC API와 교류한다는 의미이다.

만약 JPA를 통해서 데이터를 저장한다고 하자.

1. Java 애플리케이션에서 JPA에게 객체를 넘긴다.
2. 객체를 받은 JPA는 Enity를 분석한다.
3. JPA는 INSERT SQL를 생성한다.
4. JPA는 JDBC API를 사용하여 DB에 INSERT SQL를 전달한다.

여기서 중요한 것은 JPA가 SQL를 자동으로 만들어주는데 패러다임의 불일치를 해결해준다는 것이다.

<br>

### 2.4 JPA를 사용해야 하는 이유

#### 생산성

SQL를 별도로 작성하지 않아도 된다. 자바의 컬렉션처럼 사용하면 된다.

- jpa.persist(member);
- jpa.find(memberId);
- member.setName("변경할 이름");
- jpa.remove(member);

#### 유지보수

필드 변경시 모든 SQL를 수정할 필요 없다. 객체에 필드만 추가하면 된다.

#### 패러다임의 불일치 해결

객체지향언어와 관계형데이터베이스의 패러다임 불일치를 해결해준다.

- 상속

- 연관관계

- 객체 그래프 탐색
  - 지연 로딩에 있어서 필요한 시점에 객체안에 있는 객체의 정보에 대한 SQL를 불러오는 기능이 있다.

- 비교하기
  - 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장한다.

#### 성능 최적화 기능

JPA는 사용하면 오히려 성능을 끌어올릴 수 있다.

- 1차 캐시와 동일성 보장
  - 같은 트랜잭션 안에서는 같은 엔티티를 반환한다.
  - DB Isolation Level이 Read Commit이어도 애플리케이션에서 Repeatable Read를 보장한다.
- 트랜잭션을 지원하는 쓰기 지연
  - 트랜잭션을 커밋할 때까지 INSERT SQL을 모은다.
  - JDBC BATCH SQL 기능을 사용해서 한번에 SQL를 전송한다.
- 지연 로딩과 즉시 로딩
  - 지연 로딩 : 객체가 실제 사용될 때 로딩한다.
  - 즉시 로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회한다.
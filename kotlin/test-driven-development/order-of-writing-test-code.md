# 3. 테스트 코드 작성 순서

## 3.1 테스트 코드 작성 순서

이전에 테스트 케이스를 작성하는 순서는 다음과 같았다.

1. 모든 규칙을 충족하는 암호 강도는 '강함'
2. 길이만 8글자 미만이고 나머지 규칙은 충족하는 암호의 강도는 '보통'
3. 숫자를 포함하지 않고 나머지 규칙은 충족하는 암호의 강도는 '보통'
4. 값이 없는 암호의 강도는 '유호하지 않음'
5. 대문자를 포함하지 않고 나머지 규칙은 충족하는 경우
6. 길이가 8글자 이상인 규칙만 충족하는 경우
7. 숫자 포함 규칙만 충족하는 경우
8. 대문자 포함 규칙만 충족하는 경우
9. 아무 규칙도 충족하지 않는 경우

이 순서는 다음과 같은 규칙을 가지고 나오게 되었다.

1. 쉬운 경우에서 어려운 경우로 진행
2. 예외적인 경우에서 정상적인 경우

이 순서의 반대로 시행하면 구현 과정이 원활하게 진행되지 않기도 한다.

### 3.1.1 초반에 복잡한 테스트부터 시작하면 안되는 이유

테스트를 진행하기 위해 한번에 많은 코드를 작성해야하기 때문이다.

- 대문자 포함 규칙만 충족하는 경우

- 모든 규칙을 충족하는 경우

- 숫자를 포함하지 않고 나머지 규칙은 충족하는 경우


### 3.1.2 구현하기 쉬운 테스트부터 시작하기

수 분에서 십여 분 이내에 구현을 완료시킬 수 있을만큼 쉬운 테스트부터 시작한다. 암호 검사기에서는 다음 두가지가 제일 쉽다.

- 모든 조건을 충족하는 경우

- 모든 조건을 충족하지 않는 경우

책에서는 모든 조건을 충족하는 경우에 대해서 먼저 테스트를 진행하였다.

그 다음 선택지는?

- 모든 규칙을 충족하지 않는 경우

- 한 규칙만 충족하는 경우

- 두 규칙을 충족하는 경우

한가지 규칙만 체크해도 되는 로직을 테스트하는 것이 더 쉽다.

- 길이만 8글자 미만이고 나머지 규칙은 충족하는 암호의 강도는 '보통'

또는

- 길이가 8글자 이상이고 나머지 규칙은 충족하지 않은 암호의 강도는 '약함'

둘 다 길이가 8글자 이상인지 여부를 판단하는 로직만 구현하면 테스트를 통과시킬 수 있다.

이런 식으로 그다음으로 구현하기 쉬운 테스트를 선택하여 한 번에 구현하는 시간을 짧게 하여 디버깅도 쉽게 할 수 있도록 하는 것이 유리하다.

### 3.1.3 예외 상황을 먼저 테스트해야하는 이유

예외상황을 나중에 추가하는 경우 코드의 구조를 뒤집거나 코드 중간에 예외 상황을 처리하기 위해 조건문을 주옵개헛 추가하는 일이 벌어진다. 그러므로 먼저 작성해서 예외 처리를 진행해주는 것이 좋다.

### 3.1.4 완급 조절

테스트 코드를 통과시키기에 어려우면 다음과 같은 예를 통해서 구현하여 통과시키면 된다.

1. 정해진 값을 리턴
2. 값 비교를 이용해서 정해진 값을 리턴
3. 다양한 테스트를 추가하면서 구현을 일반화

예를 들어, 8글자 미만이지만 나머지 규칙은 충족하는 상황을 위 단계에 맞춰 구현을 해보자.

#### 3.1.4.1 정해진 값을 리턴
```kotlin
test("8글자 미만이지만 나머지 규칙은 충족하면 NORMAL") {
    val result1 = meter.meter("ab12!@A")
    resutl1 shouldBe PasswordStrength.NORMAL
}
```

```kotlin
class PasswordStrengthMeter {
    fun meter(s: String) = PasswordStrength.NORMAL
}
```

#### 3.1.4.2 값 비교를 이용해서 정해진 값을 리턴
```kotlin
class PasswordStrengthMeter {
    fun meter(s: String) = if(s == "ab12!@A") PasswordStrength.NORMAL 
    else PasswordStrength.STRONG
}
```


#### 3.1.4.3 다양한 테스트를 추가하면서 구현을 일반화
```kotlin
test("8글자 미만이지만 나머지 규칙은 충족하면 NORMAL") {
    val result1 = meter.meter("ab12!@A")
    resutl1 shouldBe PasswordStrength.NORMAL
    val result2 = meter.meter("Ab12!c")
    result2 shouldBe PasswordStrength.NORMAL
}
```

```kotlin
class PasswordStrengthMeter {
    fun meter(s: String) = if(s == "ab12!@A" || s == "Ab12!c") PasswordStrength.NORMAL 
    else PasswordStrength.STRONG
}
```

```kotlin
class PasswordStrengthMeter {
    fun meter(s: String) = if(s.length < 9) PasswordStrength.NORMAL 
    else PasswordStrength.STRONG
}
```

### 3.1.5 지속적인 리펙토링

테스트를 통과하면 무조건 리펙토링을 해야하는 것은 아니다. 

리펙토링은 리펙토링할 대상이 될 후보가 생기면 진행을 해야한다.

한번에 모든 코드를 리펙토링을 하는 것이 아니기 때문에 리펙토링하기도 쉽고 리펙토링을 통해 코드의 가독성도 높아진다.

> 리펙토링할 때 주의해야할 점
- 일단 동작하는 코드를 만드는 것이 중요하다.
- 코드를 잘 변경할 수 있는 능력이 중요하다.
- 코드를 쉽게 변경할 수 있는 구조여야 한다.
- 상수를 변수로 바꾸거나 변수 이름을 변경하는 것과 같은 작은 리펙토링은 발견하면 바로 시행한다.
- 메소드 추출이나 메서드 구조에 영향이 가는 것은 큰 틀에서 구현 흐름이 눈에 들어오기 시작한 뒤에 진행한다.
- 한번에 너무 많은 코드를 바꾸려고 하지 말고 전체적인 흐름을 이해한 뒤에 수정해야한다.

## 3.2 테스트 작선 순서 연습

매달 비용을 지불해야 사용할 수 있는 유료 서비스를 예제로 진행을 해보도록 하자.

- 서비스를 사용하려면 매달 1만 원을 선불로 납부한다. 납부일 기준으로 한 달 뒤가 서비스 만료일이 된다.
- 2개월 이상 요금을 납부할 수 있다.
- 10만 원을 납부하면 서비스를 1년 제공한다.

먼저, 클래스 이름을 지정하는데 만료일을 게산한다는 의미로 다음과 같이 클래스를 작성한다.

```kotlin
class ExpiryDateCalculatorTest {

}
```

#### 3.2.1 쉬운 것부터 테스트

테스트 케이스를 추가할 때는 다음 두 가지를 고려해야한다.

- 구현하기 쉬운 것부터 먼저 테스트
- 예외 상황을 먼저 테스트

예상할 수 있는 테스트 케이스는 다음과 같다.

- 1만원 납부시 한 달뒤가 만료일 
- 달의 마지막 날에 납부하면 다음달 마지막 날이 만료일
- 2만원 납부시 2개월 뒤가 만료일
- 3만원 납부시 3개월 뒤가 만료일
- 10만원 납부시 만료일은 1년 뒤가 만료일

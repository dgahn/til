# How the Actor Model Meets the Needs of Modern, Distributed Systems

이전 주제에서 설명 했듯이 일반적인 프로그래밍 방법은 까다로운 최신 시스템의 요구를 제대로 해결하지 못한다. 고맙데고 우리가 아는 모든 것을 고민할 필요가 없다.
대신에, 액터 모델은 이러한 단점을 원칙적으로 해결하여 시스템이 우리의 모델과 더 잘 어울리는 방식으로 동작할 수 있게 한다.
액터 모델 추상화를 사용하면 대규모 조직의 사람들 사이에서 발생하는 교환과 달리 커뮤니케이션 측면에서 코드를 생각할 수 있다.

액터는 다음과 같은 사항을 허락한다.

- 잠금에 의지하지 않고 캡슐화를 시행한다.
- 신호에 반응하고, 상태를 변경하고, 서로 신호를 보내어 전체 응용 프로그램을 진행시키는 협력적인 엔티티 모델을 사용한다.
- 우리의 세계관과 일치하지 않는 실행 메커니즘에 대해 걱정하지 않아도 된다.

## Usage of message passing avoids locking and blocking

메소드를 호출하는 것 대신에 actor들은 서로 메시지를 보낸다. 메시지를 전송해도 실행 스레드가 발신자에서 대상으로 전송되지 않습니다.
Actor는 메시지를 보내고 차단하지 않고 계속 할 수 있다. 그러므로, 같은 시간에 더 많은 것을 성취할 수 있다.

객체를 사용하면 메서드가 반환될 때 실행 스레드 제어가 해제된다. 이와 관련하여, Actor는 객체와 매우 유사하게 행동한다.
현재 메시지 처리가 완료되면 메시지에 반응하고 실행을 반환한다. 이런 식으로 Actor는 실제로 객체에 대해 상상했던 실행을 달성한다.

<figure>
  <img src="https://imgur.com/WOxIayW.png">
  <figcaption>출처 : https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html</figcaption>
</figure>

메시지 전달과 호출 방법의 중요한 차이점은 메시지에 반환 값이 없다는 것이다. 
메시지를 보내면 actor는 다른 actor에게 작업을 위임한다. 
[The illusion of a call stack](https://doc.akka.io/docs/akka/current/typed/guide/actors-motivation.html#the-illusion-of-a-call-stack)
에서 보았듯이 리턴 값이 예상되면 보내는 actor는 동일한 스레드에서 다른 actor의 작업을 차단하거나 실행해야한다. 대신, 수신 actor는 결과를
회신메시지로 전달한다.

Actor 모델에서 주요한 두 번째 변경 사항은 캡슐화를 복원하는 것이다. Actor는 객체에 대해 호출된 메소드에 "반응"하는 것처럼
메시지에 반응한다. 차이점은 여러 스레드가 액터로 "돌출된" 내부 상태 및 불변으로 혼란을 일으키지 않고, 
Actor는 메시지를 보낸 사람과 독립적으로 실행되며 한번에 하나씩 순차적으로 들어오는 메시지에 반응한다.
각 Actor가 순차적으로 보낸 메시지를 처리하는 동안 다른 Actor가 서로 동시에 작동하여 Actor 시스템이 
하드웨어가 지원하는 만큼 많은 메시지를 동시에 처리할 수 있다.

Actor당 항상 최대 하나의 메시지가 처리되므로 Actor의 불변량은 동기화 없이 유지 될 수 있다. 잠금을 사용하지 않고 자동으로 발생한다.

<figure>
  <img src="https://imgur.com/eJUisAD.png">
  <figcaption>출처 : https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html</figcaption>
</figure>


요약하면, Actor가 메시지를 받을 때 일어나는 일은 다음과 같다.

1. Actor는 메시지를 큐의 끝에 더한다.
2. Actor가 실행 예약되지 않은 경우 실행할 준비가 된 것으로 표시된다.
3. 스케줄러 엔티티는 Actor를 가져와서 실행을 시작한다.
4. Actor는 큐의 앞면에서 메시지를 선택한다.
5. Actor는 내부 상태를 수정하고 다른 Actor에게 메시지를 보낸다.
6. Actor의 스케쥴이 끝난다.

이 행돌을 하기 위해, Actor는 다음을 가지고 있다.

- mailbox (message가 끝나는 Queue)
- A behavior (Acotr의 상태, 내부 변수 등.)
- message (메소드 호출 및 해당 매개 변수와 유사한 신호를 나타내는 데이터 조각)
- An execution environment (메시지를 가지고 있는 Actor가 메시지 처리 코드에 반응하고 이를 호출하는 기계류)
- An address (나중에 자세히 설명)

Messages은 Actor의 mailbox들로 들어간다. behavior에 message에 대해서 어떻게 Actor가 반응하는지를 묘사한다. 
실행 환경은 스레드 풀을 조정하여 이러한 모든 작업을 완전히 투명하게 수행한다.

이는 매우 간단한 모델이고 이전에 열거된 문제를 해결한다.

- signaling과 실행을 분리함으로써 캡슐화를 보존한다. (메소드 호출 전송 실행, 메시지 전달이 수행되지 않음)
- 잠금이 절대 없다. 메시지를 통해서만 내부 상태를 수정할 수 있다. 이는 불변을 유지하려고 할 때 경쟁을 없애고 한번에 하나씩 처리한다.
- 어디서든지 잠금이 없기 때문에 발신자는 블락당하는 일이 없다. 현대 CPU의 최대 잠재력에 도달하는 수십 개의 스레드에서 수백만의 Actor를 효율적으로 예약할 수 있다.
  과제 위임은 Actor의 기능에 의해 자연스럽게 이루어진다.
- Actor의 상태는 로컬이고 공유되지 않는다. 변경 및 데이터는 메시지를 통해 전파되며, 이는 현대 메모리 계층이 실제로 작동하는 방식에 매핑된다.
  대부분, 로컬 상태 및 데이터를 원래 코어에 캐시 된 상태로 유지하면서 메시지에 데이터가 포함 된 캐시 라인만 전송함을 의미한다.
  동일한 모델은 시스템의 RAM에 상태가 유지되고 변경 / 데이터가 네트워크를 통해 패킷으로 전파되는 원격 통신에 정확하게 매핑된다.

## Acotrs handle error sutuations gracefully

더 이상 서로에게 메시지를 보내는 Actor간에 공유 호출 스택이 없기 때문에, 에러 상황을 다르게 처리할 수 있어야 한다. 고려해야하는 에러는 종류는 두가지가 있다.

- 먼저, 작업의 오류로 인해 대상 Actor에서 위임된 작업이 실패한 경우다. 이런 경우, 대상 Actor에 의해 캡슐화 된 서비스는 손상되지 않고 자체적으로 잘못된 작업이다.
  서비스 Actor는 발신자에게 메시지를 보내서 오류 사례를 제시해야한다. 오류 사례를 보내는 것은 특별한 것이 없고 오류는 도메인의 일부이기 때문에 일반 메시지가 된다.

- 두 번째 경우는 서비스 자체에 내부 오류가 발생하는 경우다. Akka는 모든 Actor가 트리와 같은 계층 구조로 구성되도록 강요한다. 즉, 다른 Actor를 생성하는 Actor는 새 Actor의 부모가 된다.
  이것은 운영체제가 프로세스를 트리로 구성하는 방법과 매우 유사하다. 프로세스와 마찬가지로 Actor가 실패하면 부모 Actor가 실패에 대응하는 방법을 결정할 수 있다.
  또한 부모 Actor가 멈추면, 부모의 Actor의 child Actor들은 모두 멈춘다. 이 서비스를 supervision이라고 하며 Akka의 중심이다.

supervisor 전략은 일반적으로 부모 Actor가 child actor를 시작할 때 정의한다. 특정 유향의 실패에서 child Actor를 다시 시작하거나
다른 유형에서는 완전히 중지시킬 수 있다. child Actor들은 조용히 죽지 않고 (단, 무한 루프인 경우 제외) supervisor 전략에 반응하거나 멈출 수 있다. (이 경우 child Actor에 관심이 있는 쪽에 통지한다.)
Actor를 관리하는 책임은 항상 부모 Actor이다. 외부에서는 재시작이 보이지 않는다. 협업 Actor들은 대상 Actor가 재시작하는 동안 계속 메시지를 보낼 수 있다.


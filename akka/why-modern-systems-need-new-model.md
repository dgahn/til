# Why modern systems need a new programming model

Actor 모델은 수십년 동시성 프로세싱에서 high performance networking을 다루기 위한 방법으로 **Carl Hewitt**에 의해 제안됬다. (당시에는 사용할 수 없는 환경이었다.)
오늘 날, 하드웨어와 인프라 기능은 **Carl Hewitt**가 생각한 비전을 따라가거나 넘어섰다. 결과적으로, 분산 시스템으로 만들어진 조직들은 전통적인 OOP 모델이 가진 문제에 대해서 맞서는 것이 필요해졌다. 그리고 actor model로 부터 그 해결에 대한 이점을 얻을 수 있다.

actor model은 효과적인 해결책으로 인식될 뿐만 아니라 몇몇 애플리케이션의 생산성도 향상시켜주고 있다. 이 주제는 기존의 프로그래밍 assumptions과 현대 멀티 스레드, 멀티 코어 아키텍처간의 불일치를 설명한다.

- The challenge of encapsulation
- The illusion of shared memory on modern computer architectures
- The illusion of a call stack

## The challenge of encapsulation

OOP의 핵심 기둥은 캡슐화이다. 캡슐화는 객체의 내부적인 데이터를 외부에서 접근하지 못하도록 한다. 이 데이터는 오직 데이터를 관리하는 메소드를 통해서만 수정이 가능하다. 객체는 안전하게 기능을 노출해야하는 의무가 있고 그것을 통해 캡슐화된 데이터의 변하지 않는 특성을 보호한다.

예를 들어, 정렬된 이진 트리 구현에 대한 연산은 트리 순서 불변을 위반하면 안된다. 호출하는 쪽은 트리를 어떤 데이터를 트리로부터 질의했을 때, 손대지 않는 순서를 기대한다. 호출하는 쪽은 이 제약에 의존 할 수 있어야 한다.

OOP 실행 시간 behavior을 분석할 때, 우리는 method 호출을 상호작용할 수 있는 것을 볼 수 있는 message sequence chart를 그릴 수 있다. 

<figure>
  <img src="https://imgur.com/WmMHfPH.png">
  <figcaption>출처 : https://doc.akka.io/docs/akka/current/typed/guide/actors-motivation.html</figcaption>
</figure>

불행하게도, 위의 diagram은 실행 중일 때, 인스턴스의 수명 선을 정확하게 나타내지 않는다. 실제로, 스레드는 이러한 모든 호출을 실행한다. 그리고 메소드가 호출됬을 때 불변성은 같은 스레드안에서 지켜진다. 스레드의 실행 포함한 다이어그램을 업데이트하면 다음과 같다.


<figure>
  <img src="https://imgur.com/e3yJA9A.png">
  <figcaption>출처 : https://doc.akka.io/docs/akka/current/typed/guide/actors-motivation.html</figcaption>
</figure>

이 설명의 중요성은 여러 스레드에서 발생하는 상황을 모델링할 때 명확해진다. 멀티 스레드에서 같은 인스턴스를 접근하는 것은 다음과 같이 설명할 수 있다.

<figure>
  <img src="https://imgur.com/8hlqAKK.png">
  <figcaption>출처 : https://doc.akka.io/docs/akka/current/typed/guide/actors-motivation.html</figcaption>
</figure>

그러므로 실행 섹션은 두 스레드가 같은 메소드에 들어가는 것을 말한다. 
불행히도 객체의 캡슐화 모델은 이 섹션에서 일어나는 것에 대해서 보증하지 않는다. 
두 호출에 대한 지시는 임의의 방식으로 인터리브 될 수 있어 두 스레드 사이에 어떤 유형의 조정 없이도 불변 값을 그대로 유지하지 못할 수도 있다.
많은 스레드에서 의해서 존재하는 이 이슈에 대해서 상상해봐라

이 문제를 접근하기 위한 일반적인 해결책은 메소드에 락을 거는 것이다. 
이렇게 하면 반드시 하나의 스레드가 하나의 메소드에 입력될 수 있지만 비용이 많이 든다.

- **Locks**은 동시성을 제한한다. 그리고 현대 CPU 아키텍처에서 매우 많은 비용이 들게하고 스레드를 일시 중단하고 나중에 복원하기 위해 운영체제에서 과도하게 리프팅을 해야한다.
- 호출 스레드는 블럭이 되면 다른 의미 있는 일을 하지 못한다. 심지어 데스크탑 애플리케이션은 이를 받아들일 수도 없다. 우리는 응용 프로그램의 UI 부분은 유지하고 싶다. 그래서 긴 백그라운 작업이 실행 중인 경우에도 UI는 반응한다.
  백그라운드에서 블락킹은 완전한 낭비이다. 새로운 스레드를 시작하여 이를 보완할 수 있다고 생각할 수도 있지만 스레드는 고비용의 추상화다.
- **Locks**는 데드락과 같은 새로운 위협을 가져오기도 한다.

이러한 현실이 좋지 않은 상황을 초래한다.

- 충분한 Locks 없으면 상태가 손상된다.
- 많은 **Locks** 장치가 있으면 성능이 저하되고 교착 상태가 발생하기 쉽다.

게다가, locks은 지역적으로 많이 발생한다. 여러 컴퓨터에서 조정하는 경우, 유일한 대안은 분산 **Locks**이다. 
불행하게도, 분산 **Locks**은 로컬 **Locks**보다 몇배나 덜 효율적이며 일반적으로 확장에 엄격한 제한을 부과한다. 
분산 락 프로토콜은 여러 시스템에서 네트워크를 통해 여러 번의 통신 왕복이 필요하므로 대기 시간이 길어진다.

일반적으로 객체 지향 언어에서 스레드나 절차 실행에 대해서 생각하지 않는다. 
우리는 시스템을 메소드 호출에 반응하고 내부 상태를 수정 한 다음 전체 애플리케이션 상태를 진행시키는 메소드 호출을 통해 
서로 통신하는 객체 인스턴스 네트워크로 생각한다.

<figure>
  <img src="https://imgur.com/rIO2VBP.png">
  <figcaption>출처 : https://doc.akka.io/docs/akka/current/typed/guide/actors-motivation.html</figcaption>
</figure>

그러나, 멀티 스레드 분산 환경에서 실제로 발생하는 것은 스레드가 메소드 호출을 통해 객체 인스턴스 네트워크를 "횡단" 하는 것이다. 
그 결과로, 스레드는 실제로 실행을 유도하는 요소다.

<figure>
  <img src="https://imgur.com/15X31wT.png">
  <figcaption>출처 : https://doc.akka.io/docs/akka/current/typed/guide/actors-motivation.html</figcaption>
</figure>

#### 요약

- 객체들은 오직 싱글 스레드 접속일 때만 캡슐화를 보증한다. 멀티 스레드는 거의 항상 내부 상태를 손상시킨다. 
  동일한 코드 부분에 두 개의 스레드가 횡단하고 있으면 모든 고정 변수를 바꿀 수가 있다.

- **Locks**은 여러 스레드로 캡슐화를 유지하는 자연스러운 치료법인 것처럼 보이지만, 사실 비효율적이고 현실 규모의 애플리케이션에서는 데드락에 빠지기 쉽다.

- **Locks**은 로컬로 작동하여 분산시키려고 하지만 확장에 대해 제한적이다.


## The illusion of shared memory on modern computer architectures

80-90년대 메모리 모델은 변수를 메모리에 쓰는 방법으로 다양한 방법을 개념화하였다. 
현대 아키텍처에서 CPU는 직접적으로 메모리에 쓰는 것 대신 cache lines에 쓴다.
대부분의 캐시들은 CPU 코어에 위치한다. 그리고 그것들은 하나의 코어만 쓰고 다른 곳에서는 볼 수가 없다. 
로컬 변경 사항을 다른 코어 및 다른 스레드에 표시하려면 캐시 라인을 다른 코어의 캐시로 전송해야한다.

JVM에서 휘발성 마커 또는 원자 래퍼를 사용하여 스레드간에 공유할 메모리 위치를 명시적으로 표시한다. 그렇지 않으면 잠긴 섹션에서만 액세스 할 수 있다.
왜 우리는 모든 변수에 휘발성 마크처럼 마킹하지 않을까? 코어들간에 캐시라인을 전송하는것은 배우 비용이 비싼 기능이기 때문이다. 
그렇게하면 추가 작업을 하는데 관련된 코어가 내재적으로 정지된다. 
그리고 캐시 일관성 프로토콜에 병목 현상이 발생한다.(protocol CPU는 주 메모리와 다른 CPU 사이에서 캐시라인을 전송한다.)

이러한 상황을 알고 있는 개발자들조차 어느 메모리 위치가 휘발성으로 표시되어야하는지 또는 어떤 원자 구조를 사용해야하는 알아는 것은 어두운 기술이다.

#### 요약

- 더 이상 실제 공유 메모리가 없으며 CPU 코어는 네트워크상의 컴퓨터가 하는 것처럼 데이터를 명시적으로 서로에게 전달한다.
  CPU 간 통신과 네트워크 통신은 많은 사람들이 알고 있는 것보다 공통점이 많다. 메시지 전달은 CPU 또는 네트워크 컴퓨터 전체서 일반적이다.

- 메시지 전달 측면을 공유 또는 원자 데이터 구조를 사용하여 표시된 변수를 통해 숨기는 대신, 보다 규율되고 원칙적인 접근 방식은 상태를 
  동시 엔티티에 로컬로 유지하고 메시지를 통해 명시적으로 동시 엔티티 간에 데이터 또는 이벤트를 전파하는 것이다.

## The illusion of a call stack

우리는 콜 스택을 당연한 것으로 여긴다. 하지만, 그것들은 다중 CPU 시스템이 일반적이지 않아 동시 프로그래밍이 중요하지 않은 시대에 발명되었다.
호출 스택은 스레드를 교차하지 않기 때문에 비동기 호출 체인 모델링을 하지 않는다.

이 문제는 스레드가 과제를 백그라운드로 위임할 때 발생한다. 실제로 이것은 다른 스레드에 작업을 위임하는 것을 의미한다. 
이것은 간단한 메소드/함수 호출이 아니다. 엄밀히 말하면 호출은 스레드에 대해 엄격하게 로컬이다. 
일반적으로 발생하는 것은 "호출자"가 객체를 작업자 스레드가 공유하는 메모리 위치("callee")에 넣는 것이다.
차례로, 일부 이벤트 루프에서 가져간다. 이를 통해 "호출자" 스레드가 다른 작업을 수행 할 수 있다.

첫번째 이슈는 어떻게 "호출자"가 그 과제의 완료를 아는지다. 하지만 좀 더 심각한 문제는 과제가 예외와 함께 발생했을 경우다. 
예외는 어디에 전파되는가? 실제 "호출자"가 누구인지 완전히 무시하는 작업자 스레드의 예외 처리기로 전파된다.

<figure>
  <img src="https://imgur.com/2v5832J.png">
  <figcaption>출처 : https://doc.akka.io/docs/akka/current/typed/guide/actors-motivation.html</figcaption>
</figure>

이것은 심각한 문제이다. 어떻게 작업자 스레드가 이를 다룰까? 일반적으로 실패한 작업의 목적을 모르기 때문에 문제를 해결할 수 없다.
"호출자" 스레드는 예외를 받아야한다. 하지만 예외를 해결하기 위한 호출 스택이 없다. 실패 알림은 사이드 채널을 통해서만 수행할 수 있다. 
예를 들어, "호출자" 스레드가 준비가 되면 결과를 기대하는 곳에 오류 코드를 넣는다. 만약 이 알림이 위치하지 않다면 
"호출자" 스레드는 결코 실패의 알림을 받을 수 없고 그 과제는 읽게 된다. 이것은 놀랍게도 메시지 / 요청이 알림 없이 손실 / 실패
할 수 있는지 네트워크 시스템 작동 방식과 유사하다.

이 나쁜 상황은 상황이 실제로 잘못되고 스레드로 지원되는 작업자에게 버그가 발생하여 복구 할 수 없는 상황이 되면 악화된다. 예를 들어,
스레드의 루트까지 버그로 인해 발생하는 매부 예외는 스레드를 종료시킨다. 
그러면 스레드에 의해 호스팅 되는 서비스의 정상적인 작동을 누가 다시 시작했는지 
그리고 어떻게 정상적인 상태로 복원해야할까? 언뜻보기에 관리하기 쉬운 것처럼 보일 수 있다. 하지만 갑자기 예기치 않은 새로운 현상이
발생한다. 스레드가 현재 작업 중이었던 실제 작업이 더 이상 작업을 수행하는 공유 메모리 위치에 없다. 
실제로 예외가 맨 위에 도달하여 모든 호출 스택을 해제하면 작업 상태가 완전히 손실된다. 네트워킹이 포함되지 않은 로컬 통신에도 메시지가 손실된다.

#### 요약

- 현재 시스템에 의미있는 동시성 및 성능 달성하기 위해 스레드는 차단하지 않고 효율적인 방식으로 서로의 작업을 위임해야한다.
  이러한 스타일의 작업 위임 동시성에서는 스택 기반 오류 처리가 중단되고 새롭고 명확한 오류 신호 메커니즘이 도입되어야 한다. 장애가 도메인 모델의 일부가 된다.

- 작업 위임이 있는 동시 시스템은 서비스 결함을 처리하고 이를 복구 할 수 있는 원칙적인 수단을 가지고 있어야 한다. 이러한 서비스의 클라이언트는 다시 시작하는 동안 작업 / 메시지가 손실 될 수 있음을 알고 있어야 한다.
  손실이 발생하지 않더라도 이전에 대기중인 작업, 가비지 수집으로 인한 지연등으로 인해 응답이 임의로 지연될 수 있다. 이러한 상황에서 동시 시스템은 
  제한 시간 형식으로 응답 마감 시간을 처리해야한다.
